### Архитектура ПО
> Этот репозиторий нужен для документирования, какие существуют в ообщем архитектуры web и не только приложений, в какизх случаях они используются и что из себя представляют.
---
## Введение

**Проблематика**

Создавая приложение по модульно, наращиваются слишком большие связи между модулями, что в будущем ведет к сложности восприятия и рефакторинга.

Сложность = Деньги = Времени.

Модули должны обладать:

- сильной связанностью (направленные на решение одной четко задачи);
- слабой зацепленностью (как можно менее зависимые от других модулей). 

**Определение**

Архитектура – набор модулей/компонентов и связей между этими компонентами.

Принципы, которые должны работать:

- dry;
- kiss;
- solid;
- patterns.

  Удаление/изменение модуля должно быть простым.

**Работа в команде**

Строгое описание помогает улучшить качество.

**Уровни архитектуры**

Уровни:

- архитектура микросервисных приложений;
- архитектура приложение:
  1. mvc;
  2. чистая архитектура;
  3. onion (многослойная);
  4. архитектура frontend приложений;
  5. реактивная архитектура.
---
## MV* Архитектуры

**Паттерн MVC**

**Основная суть**

Разделение интерфейса от бизнес-логики.

**Проблематика**

При связанных ui и бизнес логики, не получиться отделить их друг от друга, если понадобиться использовать, что-то одно из этих двух составляющих.

View(представление) обращается не напрямую к логике, а только через controller взаимодействует с model.

**Итоги**

В модели - логика, в контроллере - управление/валидация входных данных, во вью - отображение.

**Пример MVC приложения**

Ссылка на проект: <https://github.com/CurlyBattery/software-architecture/tree/main/mvc-node>

**Паттерн MVVM**

Вместо контроллера в MVC здесь выступает ViewModel.

**Flow**

Пользователь взаимодействует с ui, это изменяет данные во view, view отправляет новые данные в view model, view model напрвляет их в model, где уже нахдится бизнес логика.

## Эволюция web приложений

**Начало**

World wide web - 1990, изначально это обмен документами, страницами, которые связаны гиперссылками. -> <br> 
Далее появился css. -> <br>
С сервера начали отправлять html-страницы. -> <br>
Появляется backend, который уже может общаться с базой данных и отправлять динамические данные. -> <br>
Далее появляется javascript, предназначенный для создания динамики и логики на страницах. -><br>
С появлением асинхронных запросов, фронтенд уже не перезагружал страницу, пока приходят данные с сервера, а ждал пока они придут и получал json, а не всю страницу целиком. -><br>
Вместо большого количества html страниц начали использовать spa - single page application.-> <br>
Теперь html, css, js файлы отправляет не бэкенд, в web server по типу apache или nginx. -><br>
Когда файлов теперь приходится отправлять слишком много, на помощь приходят сборщики vite/rollup/webpack. -><br>
На замену реляционным базам данных появляются nosql базы данных(например mongodb), а также cache базы данных, для быстрого доступа к данных(redis). -><br>
Для автоматизации процесса развертывания web приложения начинают использовать ci/cd pipeline, приложения начинают упаковывать в docker контейнеры. -><br>
Монолит заменяется микросервисами для больших приложений, с большим количеством разнопланового содержания. Каждый из микросервисом обладает своим ci/cd pipeline для удобства развертывания каждого из сервисом.
Появляется api gateway для единого шлюза обращения ко всем сервисам, занимается перенаправлением. -><br>
Для хранения большого количества файлов начинают использовать сервис s3 - simple storage service(amazon, s3). -><br>
Появляется потребность в аналитике clickHouse, база данных предназначенная для быстрого доступа к аналитическим данным. -><br>
Чтобы сообщения не терялись при обмене микросервисов, начали появляться брокеры сообщений(rabbitmq, kafka). -><br>
Для регулярных действий, например для рассылки писем в 9 утра, появляется планировщик(scheduler). -><br>
Появляется надобность в разделении дата центров(балансировщик), которые обращаются к одинаковым сервисам, во избежание, потере доступа ко всем данным, если не работает единый дата центр. Что касается фронтенда, то сервес nginx тоже надо разделять по разным дата центрам. -><br>
На фронтенде тоже появляется необходимость использования монорепозиториев с микросервисами и пакетами, в которых хранятся общий ui kit, общая конфигурация. -><br>
Для полнотекстового поиска используется elastic search. -><br>
Управлением контейнерами занимается kubernetes. -><br>
Для обмена данных бэкенда и фронетенда используется rest api, soap, graphql, grpc. -><br>
Для real-time взаимодействий используется web sockets. -> <br>
Для обработки больших данных big data используются инструменты hadoop, hdfs. -><br>

